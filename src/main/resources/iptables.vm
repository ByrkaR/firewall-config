# Generated by firewall-config
*filter
:INPUT   DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT  DROP [0:0]

# loopback interface
-A INPUT  -i lo -j ACCEPT
-A OUTPUT -o lo -j ACCEPT

# simple atacks
-A INPUT -p tcp -m tcp ! --tcp-flags FIN,SYN,RST,ACK SYN -m state --state NEW -m limit --limit 5/min --limit-burst 7 -j LOG --log-prefix "Drop Sync"
-A INPUT -p tcp -m tcp ! --tcp-flags FIN,SYN,RST,ACK SYN -m state --state NEW -j DROP
-A INPUT -f -m limit --limit 5/min --limit-burst 7 -j LOG --log-prefix "Fragments Packets"
-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,PSH,ACK,URG FIN,PSH,URG -j DROP
-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,PSH,ACK,URG FIN,SYN,RST,PSH,ACK,URG -j DROP
-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,PSH,ACK,URG NONE -m limit --limit 5/min --limit-burst 7 -j LOG --log-prefix "NULL Packets"
-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,PSH,ACK,URG NONE -j DROP
-A INPUT -p tcp -m tcp --tcp-flags SYN,RST SYN,RST -j DROP
-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN FIN,SYN -m limit --limit 5/min --limit-burst 7 -j LOG --log-prefix "XMAS Packets"
-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN FIN,SYN -j DROP
-A INPUT -p tcp -m tcp --tcp-flags FIN,ACK FIN -m limit --limit 5/min --limit-burst 7 -j LOG --log-prefix "Fin Packets Scan"
-A INPUT -p tcp -m tcp --tcp-flags FIN,ACK FIN -j DROP
-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,PSH,ACK,URG FIN,SYN,RST,ACK,URG -j DROP


#
# INPUT packets
#
#foreach( $p in $input-packets )
# $p.source_address_name -> $p.app_protocol
#if ($p.destination_port > 0 )
-A INPUT  -i $p.input_interface -p $p.protocol -m $p.protocol -s $p.source_address --dport $p.destination_port -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT
-A OUTPUT -o $p.input_interface -p $p.protocol -m $p.protocol -d $p.source_address --sport $p.destination_port -m state --state RELATED,ESTABLISHED -j ACCEPT
#else
-A INPUT  -i $p.input_interface -p $p.protocol -s $p.source_address -j ACCEPT
#end

#end

#
# OUTPUT packets
#
-A OUTPUT -p icmp -j ACCEPT
#foreach( $p in $output-packets )
# $p.app_protocol://$p.destination_address_name   $p.source_service $p.source_to_dest_service_sign $p.destination_service
#if ($p.destination_port > 0 )
-A OUTPUT -p $p.protocol -m $p.protocol -d $p.destination_address --dport $p.destination_port -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT
-A INPUT  -p $p.protocol -m $p.protocol -s $p.destination_address --sport $p.destination_port -m state --state RELATED,ESTABLISHED -j ACCEPT
#else
-A OUTPUT -p $p.protocol -d $p.destination_address -j ACCEPT
#end

#end

#if ($vrrp-packets.size() > 0)
#
# VRRP
#foreach( $p in $vrrp-packets )
# $p.local_interface -> $p.remote_host.$p.remote_interface
-A INPUT  -p vrrp -i $p.local_interface -s $p.remote_address -d 224.0.0.0/8 -j ACCEPT
-A OUTPUT -p vrrp -o $p.local_interface -s $p.local_address  -d 224.0.0.0/8 -j ACCEPT

#end
#end

#if ($linked-vrrp-packets.size() > 0)
#
# Linked VRRP
#foreach( $p in $$linked-vrrp-packets )
# $p.remote_host:$p.virtual_address -> broadcast
-A INPUT  -p vrrp -i $p.local_interface -s $p.remote_address -d 224.0.0.0/8 -j ACCEPT

#end
#end

#
# FORWARD packets 2
#
-A OUTPUT -p icmp  -j ACCEPT
#foreach( $p in $forward-packets )
# $p.source_address_name -> $p.app_protocol://$p.destination_address_name   $p.source_service $p.source_to_dest_service_sign $p.destination_service
#if ($p.destination_port > 0 )
-A FORWARD -s $p.source_address -d $p.destination_address -i $p.input_interface -o $p.output_interface -p $p.protocol -m $p.protocol --dport $p.destination_port -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -s $p.destination_address -d $p.source_address -i $p.output_interface -o $p.input_interface -p $p.protocol -m $p.protocol --sport $p.destination_port -m state --state RELATED,ESTABLISHED -j ACCEPT
#else
-A FORWARD -s $p.source_address -d $p.destination_address -i $p.input_interface -o $p.output_interface -p $p.protocol  -j ACCEPT
#end

#end


-A OUTPUT -j LOG --log-prefix "Drop output packet:"
-A INPUT -j LOG --log-prefix "Drop input packet:"
-A FORWARD -j LOG --log-prefix "Drop forward packet:"

-A OUTPUT  -j REJECT
-A INPUT   -j REJECT
-A FORWARD -j REJECT

COMMIT

# default policy is ACCEPT because nat is virtual and packet pass FORWARD chain always
*nat
:PREROUTING  ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT      ACCEPT [0:0]

#foreach( $p in $forward-packets )
#if ($p.type == "SNAT")
# $p.source_address_name -> $p.app_protocol://$p.destination_address_name    $p.source_service $p.source_to_dest_service_sign $p.destination_service
#if ($p.destination_port > 0 )
-A POSTROUTING -s $p.source_address  -d $p.destination_address -p $p.protocol  --dport $p.destination_port -o $p.output_interface -j SNAT --to-source $p.source_nat_address
#else
-A POSTROUTING -s $p.source_address  -d $p.destination_address -p $p.protocol  -o $p.output_interface -j SNAT --to-source $p.source_nat_address
#end

#elseif($p.type == "DNAT")
# $p.source_address_name -> $p.app_protocol://$p.destination_address_name     $p.source_service $p.source_to_dest_service_sign $p.destination_service
#if ($p.destination_port > 0 )
-A PREROUTING -d $p.destination_nat_address -p $p.protocol -m $p.protocol --dport $p.destination_nat_port -j DNAT --to-destination $p.destination_address:$p.destination_port
#else
-A PREROUTING -d $p.destination_nat_address -p $p.protocol -j DNAT --to-destination $p.destination_address
#end

#end
#end

COMMIT
